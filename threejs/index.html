<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Neural Mapping</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f5f5f5;
      overflow: hidden;
    }
    canvas { 
      display: block;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <script src="./js/three.min.js"></script>
  <script src="./js/OrbitControls.js"></script>
  <script src="./js/THREE.MeshLine/THREE.MeshLine.js"></script>
<script type="module">


const zStep = 3.2;
const sphereRadius = 0.05;
const dotDash = 0.002;

// Load JSON data from Python export
const response = await fetch('viz_data.json');
const data = await response.json();

const { n_layers, embeddings, embeddings_nonsequential, Y, grid, d } = data;

// Build color palette
const classColors = d === 2
  ? [ new THREE.Color(1.0, 0.0, 0.0), new THREE.Color(0.0, 0.0, 1.0) ]  // red, blue
  : [
      new THREE.Color(1.000, 0.729, 0.286), // #ffba49
      new THREE.Color(0.129, 0.643, 0.620), // #20a39e
      new THREE.Color(0.937, 0.357, 0.357)  // #ef5b5b
    ];

// === Scene setup ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
//scene.fog = new THREE.Fog(0xffffff, 0, 20);

const frust = (1 + n_layers) * 1.5;
const zMid = (n_layers * zStep) / 2;

const camera = new THREE.OrthographicCamera(-frust, frust, frust, -frust, -100, 100);
camera.position.set(5, 5, 15);
camera.up.set(0, 0, 1);
camera.lookAt(0, 0, zMid);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  alpha: true,
  preserveDrawingBuffer: true
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(900, 900);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, zMid);
controls.enableDamping = true;
controls.dampingFactor = 0.25;
controls.update();

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const light = new THREE.DirectionalLight(0xffffff, 0.6);
light.position.set(10, 10, 10);
scene.add(light);

// Materials
const planeMat = new THREE.MeshBasicMaterial({
  color: 0xf3f3f3,
  transparent: true,
  opacity: 0.8,
  depthWrite: true,
  side: THREE.DoubleSide
});

const planeMat2 = new THREE.MeshBasicMaterial({
  color: 0xeeeeee,
  transparent: true,
  opacity: 0.5,
  depthWrite: true,
  side: THREE.DoubleSide
});

// Helpers
function makeDashedLine(p1, p2, color, dashSize = 0.01, gapSize = 0.01, width = 2) {
  const points = [new THREE.Vector3(...p1), new THREE.Vector3(...p2)];
  const geometry = new THREE.BufferGeometry().setFromPoints(points);

  const meshLine = new MeshLine();
  meshLine.setGeometry(geometry);

  const totalSize = dashSize + gapSize;
  const material = new MeshLineMaterial({
    color: new THREE.Color(color),
    lineWidth: width * 0.005, // empirically scaled for visual similarity
    transparent: true,
    dashArray: totalSize,
    dashOffset: 0,
    dashRatio: dashSize / totalSize,
    depthTest: true,
    depthWrite: true,
    fog: true
  });

  return new THREE.Mesh(meshLine, material);
}

// Main visualization
for (let l = 0; l <= n_layers; l++) {
  const z = l * zStep;

  // Grid lines
  [-1, 0, 1].forEach(x => {
    if (x == 0) {
      scene.add(makeDashedLine([x, -1, z], [x, 1, z], 0x777777, 0, 1, 2));
    } else {
      scene.add(makeDashedLine([x, -1, z], [x, 1, z], 0x000000, 0, 1, 2));
    }
  });
  [-1, 0, 1].forEach(y => {
    if (y == 0) {
      scene.add(makeDashedLine([-1, y, z], [1, y, z], 0x777777, 0, 1, 2));
    } else {
      scene.add(makeDashedLine([-1, y, z], [1, y, z], 0x000000, 0, 1, 2));
    }
  });

  // Translucent unit plane for the axes
  const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), planeMat);
  plane.position.set(0, 0, z);
  scene.add(plane);
  

  // Translucent plane for the transformed grid
  // if (l < embeddings_nonsequential.length) {
  //   const pts4 = embeddings_nonsequential[l].slice(0, 4);
  //   const geometry = new THREE.BufferGeometry();
  //   const vertices = [];
    
  //   // Create vertices for the transformed plane
  //   const z_epsilon = 0.0001;
  //   for (let i = 0; i < 2; i++) {
  //     for (let j = 0; j < 2; j++) {
  //       const idx = i * 2 + j;
  //       const [x, y] = pts4[idx];
  //       vertices.push(x, -y, z-z_epsilon);
  //     }
  //   }
    
  //   // Create faces (two triangles to form a quad)
  //   const indices = [
  //     0, 1, 2,  // first triangle
  //     1, 3, 2   // second triangle
  //   ];
    
  //   geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  //   geometry.setIndex(indices);
  //   geometry.computeVertexNormals();
    
  //   const transformedPlane = new THREE.Mesh(geometry, planeMat2);
  //   scene.add(transformedPlane);
  // }

  // Wireframe box showing transformed grid (first 4 pts as 2x2)
  if (l < embeddings_nonsequential.length && l > 0) {
    const pts4 = embeddings_nonsequential[l].slice(0, 4);
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < 2; j++) {
        const idx = i * 2 + j;
        const a = pts4[idx];
        if (i < 1) {
          const b = pts4[(i + 1) * 2 + j];
          scene.add(makeDashedLine([a[0], -a[1], z], [b[0], -b[1], z], 0x000000, 0.01, 0.01, 5));
        }
        if (j < 1) {
          const b = pts4[i * 2 + (j + 1)];
          scene.add(makeDashedLine([a[0], -a[1], z], [b[0], -b[1], z], 0x000000, 0.01, 0.01, 5));
        }
      }
    }
  }

  // Data points
  for (let i = 0; i < Y.length; i++) {
    const [x, y] = embeddings[l][i];
    const color = new THREE.Color(classColors[Y[i] % classColors.length]);
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(sphereRadius, 16, 16),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 })
    );
    sphere.position.set(x, -y, z);
    scene.add(sphere);
  }

  // Inter-layer lines between data points
  if (l < n_layers) {
    for (let i = 0; i < Y.length; i++) {
      const [x0, y0] = embeddings[l][i];
      const [x1, y1] = embeddings[l + 1][i];
      const color = new THREE.Color(classColors[Y[i] % classColors.length]);
      scene.add(makeDashedLine(
        [x0, -y0, z],
        [x1, -y1, z + zStep],
        color,
        dotDash,
        dotDash,
        2.5
      ));
    }
  }
}

// Mapping lines from grid
for (let l = 0; l < n_layers; l++) {
  const z0 = l * zStep;
  const z1 = (l + 1) * zStep;
  for (let i = 0; i < grid.length; i++) {
    const [x0, y0] = grid[i];
    const [x1, y1] = embeddings_nonsequential[l + 1][i];
    scene.add(makeDashedLine(
      [x0, -y0, z0],
      [x1, -y1, z1],
      0x333333,
      0.01,
      0.01,
      5
    ));
  }
}

// Animate
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
